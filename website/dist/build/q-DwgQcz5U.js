import{a as i,s as r,t as a,q as o}from"./q-dgQLQ9M1.js";import{u as n}from"./q-CyNgVds-.js";const d=[{text:"Use cases",id:"use-cases",level:1},{text:"Server requests",id:"server-requests",level:2},{text:"Form validation",id:"form-validation",level:2},{text:"Browser state",id:"browser-state",level:2},{text:"Config files",id:"config-files",level:2},{text:"Schema builder",id:"schema-builder",level:2},{text:"Data migration",id:"data-migration",level:2}],h={title:"Use cases",meta:[{name:"description",content:"Next, I would like to point out some use cases for which I am particularly well suited. I welcome ideas for other use cases that I may not have thought of yet."}],styles:[],links:[],scripts:[],frontmatter:{contributors:["fabian-hiller"]}},u={title:"Use cases",description:"Next, I would like to point out some use cases for which I am particularly well suited. I welcome ideas for other use cases that I may not have thought of yet.",contributors:["fabian-hiller"]};function s(t){const e={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",span:"span",...n(),...t.components};return a(o,{children:[a(e.h1,{id:"use-cases",children:[a(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#use-cases",children:a(e.span,{class:"icon icon-link"})}),"Use cases"]}),`
`,a(e.p,{children:["Next, we would like to point out some use cases for which Valibot is particularly well suited. We welcome ",a(e.a,{href:"https://github.com/fabian-hiller/valibot/issues/new",rel:"noreferrer",target:"_blank",children:"ideas"})," for other use cases that we may not have thought of yet."]}),`
`,a(e.h2,{id:"server-requests",children:[a(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#server-requests",children:a(e.span,{class:"icon icon-link"})}),"Server requests"]}),`
`,a(e.p,{children:"Since most API endpoints can be reached via the Internet, basically anyone can send a request and transmit data. It is therefore important to apply zero trust security and to check request data thoroughly before processing it further."}),`
`,a(e.p,{children:"This works particularly well with a schema, compared to if/else conditions, as even complex structures can be easily mapped. In addition, the library automatically type the parsed data according to the schema, which improves type safety and thus makes your code more secure."}),`
`,a(e.h2,{id:"form-validation",children:[a(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#form-validation",children:a(e.span,{class:"icon icon-link"})}),"Form validation"]}),`
`,a(e.p,{children:"A schema can also be used for form validation. Due to Valibot's small bundle size and the possibility to individualize the error messages, the library is particularly well suited for this. Also, fullstack frameworks like Next.js, Remix, and Nuxt allow the same schema to be used for validation in the browser as well as on the server, which reduces your code to the minimum."}),`
`,a(e.p,{children:[a(e.a,{href:"https://modularforms.dev/react/guides/validate-your-fields#schema-validation",rel:"noreferrer",target:"_blank",children:"Modular Forms"}),", for example, offers validation based on a schema at form and field level. In addition, the form can be made type-safe using the schema, which also enables autocompletion during development. In combination with the right framework, a fully type-safe and progressively enhanced form can be created with few lines of code and a great experience for developers and end-users."]}),`
`,a(e.h2,{id:"browser-state",children:[a(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#browser-state",children:a(e.span,{class:"icon icon-link"})}),"Browser state"]}),`
`,a(e.p,{children:"The browser state, which is stored using cookies, search parameters or the local storage, can be accidentally or intentionally manipulated by the user. To ensure the functionality of an application, it can help to validate this data before processing. Valibot can be used for this, which also improves type safety."}),`
`,a(e.h2,{id:"config-files",children:[a(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#config-files",children:a(e.span,{class:"icon icon-link"})}),"Config files"]}),`
`,a(e.p,{children:"Library authors can also make use of Valibot, for example, to match configuration files with a schema and, in the event of an error, provide clear indications of the cause and how to fix the problem. The same applies to environment variables to quickly detect configuration errors."}),`
`,a(e.h2,{id:"schema-builder",children:[a(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#schema-builder",children:a(e.span,{class:"icon icon-link"})}),"Schema builder"]}),`
`,a(e.p,{children:["Our schemas are plain JavaScript objects with a well-defined and fully type-safe structure. This makes Valibot a great choice for defining data structures that can be further processed by third-party code. For example, it is possible to build an ORM with custom metadata actions on top of Valibot to generate database schemas. Another example is our official ",a(e.code,{children:"toJsonSchema"})," function, which uses Valibot's object API to output a JSON Schema that can be used for documentation purposes or to generate structured output with LLMs."]}),`
`,a(e.h2,{id:"data-migration",children:[a(e.a,{"aria-hidden":"true",tabindex:"-1",href:"#data-migration",children:a(e.span,{class:"icon icon-link"})}),"Data migration"]}),`
`,a(e.p,{children:"Valibot can also be used to migrate data from one form to another in a type-safe way. The advantage of a schema library like Valibot is that transformations can be defined for individual properties instead of for the entire dataset. This can make data migrations more readable and maintainable. In addition, the schema can be used to validate the data before the migration, which increases the reliability of the migration process."})]})}const m=(t={})=>{const e=i(r,{children:i(s,t,3,null)},3,"ClzLzWJE");return typeof MDXLayout=="function"?a(MDXLayout,{children:e}):e};export{m as default,u as frontmatter,h as head,d as headings};
